常用工具：
	软件包管理工具：yum
		查看   未安装：yum list | grep + (softname) 以安装： yum list installed
		安装 yum install + (softname)
		移除 yum remove +(softname)
		
		lrzsz：实现linux与window之间传输文件这个工具用于 windows 机器和远端的 Linux 机器通过 XShell 传输文件.安装完毕之后可以通过拖拽的方式将文件上传过去
		从linux向window传文件：sz + (filename文件名)
		从window向linux传文件：直接拖拽值shell窗口(文件在哪里取决去当前在哪个目录当中)
	写代码相关工具：
		编辑器：vim
			模式：12种模式，常用的模式3种：插入模式、普通模式。底行模式(所用模式围绕普通模式)vim打开一个文件默认处于普通模式
			模式切换：
				有普通模式进入插入模式：
					i 切换模式、a 光标向后移动一位并且进入掺入模式、
					I 直接光标返回行并且进入插入模式、
					A 光标直接跳转至末尾并且进入插入模式
				有插入模式进入普通模式：
					ESC按键
				有普通模式进入底行模式： ：
				由底行模式返回普通模式：ESC
				底行模式功能：字符串匹配、文件的保存退出
				保存数据：
					先回普通模式，:w 保存 、 :wq 保存退出 、:q!强制推出
			普通模式下指令：
				移动光标：
					h/j/k/l(左、下、上、右) ，ctrl +f/b 向上/下翻页 gg/G跳转文档头/尾
					w/b 单词向右走/左走
				增删查该：linux赋值通常都是按行来的(在普通模式下执行)
					p:向光标所在行下一行粘贴
					yy ：复制一行 
					dd(剪切) : 删除一行
					n yy ：从光标所在位置向下复制n行(同时按住n和yy)
					n dd(剪切) : 从光标所在位置向下删除n行(同时按住n和dd)
					x 删除光标所在字符
					dw 删除光标所在单词
					u 撤销
					gg=G 全文对齐
				
		编译器：将用户所写高级语言代码解释成为机器可识别指令
			格式：格式 gcc [选项] 要编译的文件 [选项] [目标文件]
			脚本语言：不需要编译通过脚本解释器(便解释边执行)
			编译语言：c、c++需要编译(一次解释完，在运行)，性能优于脚本语言
			编译过程：
				预处理：宏定义展开、文件包含、条件编译、去掉注释等 生成.i文件
					gcc -E hello.c -o hello.i 只做到预处理
				编译：语法纠错、将代码翻译为汇编语言 生成.s文件
					gcc -S hello.i -o hello.s  只做到编译
				汇编：将汇编语言转化为机器指令，也就是.s文件转化为.o目标文件
					gcc -C hello.s -o hello.o 只做到汇编
				链接：链接将所有代码成为可执行程序
					gcc hello.o -o hello 
				gcc选项：
					-static 生成的文件采用静态链接
					-E 只激活预处理不生成文件，但是要重定向到一个输出文件中
					-S 编译到汇编语言不进行汇编和连接
					-o 输出文件到文件
					-c 编译到目标代码
					-g 生成调试信息
			
			函数库(动态链接和静态链接)
				静态链接(静态库)：静态库是指编译链接时,把库文件的代码全部加入到可执行文件中,因此生成的文件比较大造成代码冗余,但在运行时也
                就不再需要库文件了。其后缀名一般为“.a”
				动态链接(动态库)：在编译链接时并没有把库文件的代码加入到可执行文件中,而是在程序执行时由运行时链接文件加载库,这样可以节省系统的开销但是删库后程序不能运行。动态库一般后缀名为“.so”
				
			gcc 默认生成二进制程序，采用动态链接
		调试器：gdb 使用gdb调试程序的前提就是使用gcc生成debug版本可执行程序(gcc默认生成release版本)
			gdb通过命令完成整个程序调试过程：
				逐步调试：
				    run 直接运行跑起来
					start开始逐步调试
					next 下一步(不进入函数，直接运行完毕)
					list 查看调试行附近代码：list filename：line
					step 具体步骤(跟踪进入函数)
					until 直接运行到指定行：until filename：行数
					continue 继续运行(从当前位置直接运行到结束)
				断点调试：
					给指定文件的指定行打断点：break filename：line
					给指定的函数打断点：break funcname(从该函数开始的位置)
					info break 查看断点信息
					delete 删除断点
					watch 针对变量的断点(当断点内容发生改变是程序停止)
					print 打印变量内容
					
				其他调试：
					backtrace 查看函数调用栈(快速查看程序崩溃位置)
				
	项目管理工具：
		项目构建工具：make/Makefile
				Makefile：普通的文本文件但也有一点不普通(这个文件中记录一个项目的构件规则)
				make：是一个解释程序，会到当前目录下寻找Makefile文件，对Makefile中记录的的项目构件规则进行逐行解释执行，最终完成项目的构建
				Makefile的编写规则：
					目标对象：依赖对象
					[tab] + 为了生成目标对象所执行的命令
				预定义变量：
					$^ 所有的依赖对象
				    $@ 所用的目标对象
					$< 依赖对象中的第一个
				    src=$(wildcard ./*.c) 获取当前目录下所有以.c结尾的文件名放进src变量中
					obj=$(patsubst %.c,%.0,$s(src)) 关键字将src变量中的内容进行字符串替换，将.c换成.o
                    # 注释
					% 通配符
				clear：是目标对象不需要依赖对象，用它去执行一个任务	
					调用: make clear
				伪对象：不管目标对象是否最新，每次都需要从新生成
				伪对象声明：.PHONY:target——name
				make的解释执行规则：
					1.从上往下找第一个目标对象执行后并退出
					2.若依赖对象不存在，则先生成依赖对象最后生成目标对象
		项目版本管理工具：git
			从服务器上克隆一个项目：	
				git clone + 网址
			本地的版本提交：
				git add
			远程服务器提交：
				git push origin master
				
			